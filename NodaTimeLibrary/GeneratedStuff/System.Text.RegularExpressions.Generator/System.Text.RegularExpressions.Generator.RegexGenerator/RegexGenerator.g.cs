// <auto-generated/>
#nullable enable
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // Unreferenced label
#pragma warning disable CS0219 // Variable assigned but never used

namespace NodaTimeLibrary.Classes
{
    partial class Helpers
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>(^[a-z])|\\.\\s+(.)</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.ExplicitCapture</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match with 2 alternative expressions, atomically.<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match if at the beginning of the string.<br/>
        ///         ○ Match a character in the set [a-z].<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match '.'.<br/>
        ///         ○ Match a whitespace character greedily at least once.<br/>
        ///         ○ Match any character other than '\n'.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex SentenceCaseRegex() => global::System.Text.RegularExpressions.Generated.SentenceCaseRegex_0.Instance;
    }
}

namespace NodaTimeLibrary.Classes
{
    partial class Helpers
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>\\b\\w+\\b</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match if at a word boundary.<br/>
        /// ○ Match a word character atomically at least once.<br/>
        /// ○ Match if at a word boundary.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex SentenceCaseRegex1() => global::System.Text.RegularExpressions.Generated.SentenceCaseRegex1_1.Instance;
    }
}

namespace NodaTimeLibrary.Classes
{
    partial class Helpers
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>\\b\\w+</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match if at a word boundary.<br/>
        /// ○ Match a word character atomically at least once.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex MyRegex() => global::System.Text.RegularExpressions.Generated.MyRegex_2.Instance;
    }
}

namespace System.Text.RegularExpressions.Generated
{
    using System;
    using System.Buffers;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Threading;

    /// <summary>Custom <see cref="Regex"/>-derived type for the SentenceCaseRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class SentenceCaseRegex_0 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly SentenceCaseRegex_0 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private SentenceCaseRegex_0()
        {
            base.pattern = "(^[a-z])|\\.\\s+(.)";
            base.roptions = RegexOptions.ExplicitCapture;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a character in the set [.a-z].
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_ascii_40000000000000FEFFFF07);
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    int stackpos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Atomic group.
                    {
                        int atomic_stackpos = stackpos;
                        
                        // Match with 2 alternative expressions, atomically.
                        //{
                            int alternation_starting_pos = pos;
                            
                            // Branch 0
                            {
                                // Match if at the beginning of the string.
                                if (pos != 0)
                                {
                                    goto AlternationBranch;
                                }
                                
                                // Match a character in the set [a-z].
                                if (slice.IsEmpty || !char.IsAsciiLetterLower(slice[0]))
                                {
                                    goto AlternationBranch;
                                }
                                
                                pos++;
                                slice = inputSpan.Slice(pos);
                                goto AlternationMatch;
                                
                                AlternationBranch:
                                pos = alternation_starting_pos;
                                slice = inputSpan.Slice(pos);
                            }
                            
                            // Branch 1
                            {
                                // Match '.'.
                                if (slice.IsEmpty || slice[0] != '.')
                                {
                                    return false; // The input didn't match.
                                }
                                
                                // Match a whitespace character greedily at least once.
                                //{
                                    pos++;
                                    slice = inputSpan.Slice(pos);
                                    charloop_starting_pos = pos;
                                    
                                    int iteration = 0;
                                    while ((uint)iteration < (uint)slice.Length && char.IsWhiteSpace(slice[iteration]))
                                    {
                                        iteration++;
                                    }
                                    
                                    if (iteration == 0)
                                    {
                                        return false; // The input didn't match.
                                    }
                                    
                                    slice = slice.Slice(iteration);
                                    pos += iteration;
                                    
                                    charloop_ending_pos = pos;
                                    charloop_starting_pos++;
                                    goto CharLoopEnd;
                                    
                                    CharLoopBacktrack:
                                    
                                    if (Utilities.s_hasTimeout)
                                    {
                                        base.CheckTimeout();
                                    }
                                    
                                    if (charloop_starting_pos >= charloop_ending_pos ||
                                        (charloop_ending_pos = inputSpan.Slice(charloop_starting_pos, charloop_ending_pos - charloop_starting_pos).LastIndexOfAnyExcept('\n')) < 0)
                                    {
                                        return false; // The input didn't match.
                                    }
                                    charloop_ending_pos += charloop_starting_pos;
                                    pos = charloop_ending_pos;
                                    slice = inputSpan.Slice(pos);
                                    
                                    CharLoopEnd:
                                //}
                                
                                // Match any character other than '\n'.
                                if (slice.IsEmpty || slice[0] == '\n')
                                {
                                    goto CharLoopBacktrack;
                                }
                                
                                pos++;
                                slice = inputSpan.Slice(pos);
                            }
                            
                            AlternationMatch:;
                        //}
                        
                        stackpos = atomic_stackpos;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the SentenceCaseRegex1 method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class SentenceCaseRegex1_1 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly SentenceCaseRegex1_1 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private SentenceCaseRegex1_1()
        {
            base.pattern = "\\b\\w+\\b";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a word character.
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAnyWordChar();
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match if at a word boundary.
                    if (!Utilities.IsBoundary(inputSpan, pos))
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match a word character atomically at least once.
                    {
                        int iteration = 0;
                        while ((uint)iteration < (uint)slice.Length && Utilities.IsWordChar(slice[iteration]))
                        {
                            iteration++;
                        }
                        
                        if (iteration == 0)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration);
                        pos += iteration;
                    }
                    
                    // Match if at a word boundary.
                    if (!Utilities.IsBoundary(inputSpan, pos))
                    {
                        return false; // The input didn't match.
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the MyRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class MyRegex_2 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly MyRegex_2 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private MyRegex_2()
        {
            base.pattern = "\\b\\w+";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a word character.
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAnyWordChar();
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match if at a word boundary.
                    if (!Utilities.IsBoundary(inputSpan, pos))
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match a word character atomically at least once.
                    {
                        int iteration = 0;
                        while ((uint)iteration < (uint)slice.Length && Utilities.IsWordChar(slice[iteration]))
                        {
                            iteration++;
                        }
                        
                        if (iteration == 0)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration);
                        pos += iteration;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Helper methods used by generated <see cref="Regex"/>-derived implementations.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file static class Utilities
    {
        /// <summary>Default timeout value set in <see cref="AppContext"/>, or <see cref="Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        internal static readonly TimeSpan s_defaultTimeout = AppContext.GetData("REGEX_DEFAULT_MATCH_TIMEOUT") is TimeSpan timeout ? timeout : Regex.InfiniteMatchTimeout;
        
        /// <summary>Whether <see cref="s_defaultTimeout"/> is non-infinite.</summary>
        internal static readonly bool s_hasTimeout = s_defaultTimeout != Regex.InfiniteMatchTimeout;
        
        /// <summary>Finds the next index of any character that matches a word character.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int IndexOfAnyWordChar(this ReadOnlySpan<char> span)
        {
            int i = span.IndexOfAnyExcept(Utilities.s_asciiExceptWordChars);
            if ((uint)i < (uint)span.Length)
            {
                if (char.IsAscii(span[i]))
                {
                    return i;
                }
        
                do
                {
                    if (Utilities.IsWordChar(span[i]))
                    {
                        return i;
                    }
                    i++;
                }
                while ((uint)i < (uint)span.Length);
            }
        
            return -1;
        }
        
        /// <summary>Determines whether the specified index is a boundary.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool IsBoundary(ReadOnlySpan<char> inputSpan, int index)
        {
            int indexMinus1 = index - 1;
            return ((uint)indexMinus1 < (uint)inputSpan.Length && IsBoundaryWordChar(inputSpan[indexMinus1])) !=
                   ((uint)index < (uint)inputSpan.Length && IsBoundaryWordChar(inputSpan[index]));
        
            static bool IsBoundaryWordChar(char ch) => IsWordChar(ch) || (ch == '\u200C' | ch == '\u200D');
        }
        
        /// <summary>Determines whether the character is part of the [\w] set.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool IsWordChar(char ch)
        {
            // Mask of Unicode categories that combine to form [\w]
            const int WordCategoriesMask =
                1 << (int)UnicodeCategory.UppercaseLetter |
                1 << (int)UnicodeCategory.LowercaseLetter |
                1 << (int)UnicodeCategory.TitlecaseLetter |
                1 << (int)UnicodeCategory.ModifierLetter |
                1 << (int)UnicodeCategory.OtherLetter |
                1 << (int)UnicodeCategory.NonSpacingMark |
                1 << (int)UnicodeCategory.DecimalDigitNumber |
                1 << (int)UnicodeCategory.ConnectorPunctuation;
        
            // Bitmap for whether each character 0 through 127 is in [\w]
            ReadOnlySpan<byte> ascii = new byte[]
            {
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
                0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07
            };
        
            // If the char is ASCII, look it up in the bitmap. Otherwise, query its Unicode category.
            int chDiv8 = ch >> 3;
            return (uint)chDiv8 < (uint)ascii.Length ?
                (ascii[chDiv8] & (1 << (ch & 0x7))) != 0 :
                (WordCategoriesMask & (1 << (int)CharUnicodeInfo.GetUnicodeCategory(ch))) != 0;
        }
        
        /// <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^`{|}~\u007f".</summary>
        internal static readonly SearchValues<char> s_asciiExceptWordChars = SearchValues.Create("\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~\u007f");
        
        /// <summary>Supports searching for characters in or not in ".abcdefghijklmnopqrstuvwxyz".</summary>
        internal static readonly SearchValues<char> s_ascii_40000000000000FEFFFF07 = SearchValues.Create(".abcdefghijklmnopqrstuvwxyz");
    }
}
