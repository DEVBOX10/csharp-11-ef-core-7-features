// <auto-generated/>
#nullable enable
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // Unreferenced label
#pragma warning disable CS0219 // Variable assigned but never used

namespace GeneratedRegexSamplesApp.Classes
{
    partial class Examples
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>(?&lt;scheme&gt;.+?://)(?&lt;host&gt;[0-9a-z\\-\\.]+)(?&lt;path&gt;/product/(?&lt;pid&gt;\\d+))</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ "scheme" capture group.<br/>
        ///     ○ Match a character other than '\n' lazily at least once.<br/>
        ///     ○ Match the string "://".<br/>
        /// ○ "host" capture group.<br/>
        ///     ○ Match a character in the set [-.0-9A-Za-z\u0130\u212A] atomically at least once.<br/>
        /// ○ "path" capture group.<br/>
        ///     ○ Match '/'.<br/>
        ///     ○ Match a character in the set [Pp].<br/>
        ///     ○ Match a character in the set [Rr].<br/>
        ///     ○ Match a character in the set [Oo].<br/>
        ///     ○ Match a character in the set [Dd].<br/>
        ///     ○ Match a character in the set [Uu].<br/>
        ///     ○ Match a character in the set [Cc].<br/>
        ///     ○ Match a character in the set [Tt].<br/>
        ///     ○ Match '/'.<br/>
        ///     ○ "pid" capture group.<br/>
        ///         ○ Match a Unicode digit atomically at least once.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex ProductUrlRegex() => global::System.Text.RegularExpressions.Generated.ProductUrlRegex_0.Instance;
    }
}

namespace GeneratedRegexSamplesApp.Classes
{
    partial class Examples
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>\\d{1,2}/\\d{1,2}/\\d{4} \\d{1,2}:\\d{2}:\\d{2} [AP]M</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match a Unicode digit atomically at least 1 and at most 2 times.<br/>
        /// ○ Match '/'.<br/>
        /// ○ Match a Unicode digit atomically at least 1 and at most 2 times.<br/>
        /// ○ Match '/'.<br/>
        /// ○ Match a Unicode digit exactly 4 times.<br/>
        /// ○ Match ' '.<br/>
        /// ○ Match a Unicode digit atomically at least 1 and at most 2 times.<br/>
        /// ○ Match ':'.<br/>
        /// ○ Match a Unicode digit exactly 2 times.<br/>
        /// ○ Match ':'.<br/>
        /// ○ Match a Unicode digit exactly 2 times.<br/>
        /// ○ Match ' '.<br/>
        /// ○ Match a character in the set [AP].<br/>
        /// ○ Match 'M'.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex DateRegex() => global::System.Text.RegularExpressions.Generated.DateRegex_1.Instance;
    }
}

namespace GeneratedRegexSamplesApp.Classes
{
    partial class Examples
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>[0-9][0-9 ]{13,}[0-9]</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match a character in the set [0-9].<br/>
        /// ○ Match a character in the set [ 0-9] greedily at least 13 times.<br/>
        /// ○ Match a character in the set [0-9].<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex CreditCardRegex() => global::System.Text.RegularExpressions.Generated.CreditCardRegex_2.Instance;
    }
}

namespace GeneratedRegexSamplesApp.Classes
{
    partial class Examples
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>[ ]{2,}</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match ' ' atomically at least twice.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex MultipleSpacesRegex() => global::System.Text.RegularExpressions.Generated.MultipleSpacesRegex_3.Instance;
    }
}

namespace GeneratedRegexSamplesApp.Classes
{
    partial class Helpers
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>(^[a-z])|\\.\\s+(.)</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.ExplicitCapture</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match with 2 alternative expressions, atomically.<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match if at the beginning of the string.<br/>
        ///         ○ Match a character in the set [a-z].<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match '.'.<br/>
        ///         ○ Match a whitespace character greedily at least once.<br/>
        ///         ○ Match any character other than '\n'.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex SentenceCaseRegex() => global::System.Text.RegularExpressions.Generated.SentenceCaseRegex_4.Instance;
    }
}

namespace GeneratedRegexSamplesApp.Classes
{
    partial class RegularExpressionHelpers
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>^(?!\\b(\\d)\\1+\\b)(?!123456789|219099999|078051120)(?!666|000|9\\d{2})\\d{3}(?!00)\\d{2}(?!0{4})\\d{4}$</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match if at the beginning of the string.<br/>
        /// ○ Zero-width negative lookahead.<br/>
        ///     ○ Match if at a word boundary.<br/>
        ///     ○ 1st capture group.<br/>
        ///         ○ Match a Unicode digit.<br/>
        ///     ○ Loop greedily at least once.<br/>
        ///         ○ Match the same text as matched by the 1st capture group.<br/>
        ///     ○ Match if at a word boundary.<br/>
        /// ○ Zero-width negative lookahead.<br/>
        ///     ○ Match with 3 alternative expressions, atomically.<br/>
        ///         ○ Match the string "123456789".<br/>
        ///         ○ Match the string "219099999".<br/>
        ///         ○ Match the string "078051120".<br/>
        /// ○ Zero-width negative lookahead.<br/>
        ///     ○ Match with 3 alternative expressions, atomically.<br/>
        ///         ○ Match the string "666".<br/>
        ///         ○ Match the string "000".<br/>
        ///         ○ Match a sequence of expressions.<br/>
        ///             ○ Match '9'.<br/>
        ///             ○ Match a Unicode digit exactly 2 times.<br/>
        /// ○ Match a Unicode digit exactly 3 times.<br/>
        /// ○ Zero-width negative lookahead.<br/>
        ///     ○ Match the string "00".<br/>
        /// ○ Match a Unicode digit exactly 2 times.<br/>
        /// ○ Zero-width negative lookahead.<br/>
        ///     ○ Match the string "0000".<br/>
        /// ○ Match a Unicode digit exactly 4 times.<br/>
        /// ○ Match if at the end of the string or if before an ending newline.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex SSNValidationRegex() => global::System.Text.RegularExpressions.Generated.SSNValidationRegex_5.Instance;
    }
}

namespace GeneratedRegexSamplesApp.Classes
{
    partial class RegularExpressionHelpers
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>[0-9]+$</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match a character in the set [0-9] atomically at least once.<br/>
        /// ○ Match if at the end of the string or if before an ending newline.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex NumbersPatternRegex() => global::System.Text.RegularExpressions.Generated.NumbersPatternRegex_6.Instance;
    }
}

namespace GeneratedRegexSamplesApp.Classes
{
    partial class RegularExpressionHelpers
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>(?&lt;day&gt;\\d{1,2})((st)|(nd)|(rd)|(th))? (?&lt;month&gt;[A-Za-z]+) (?&lt;year&gt;\\d{4})</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ "day" capture group.<br/>
        ///     ○ Match a Unicode digit greedily at least 1 and at most 2 times.<br/>
        /// ○ Optional (greedy).<br/>
        ///     ○ 1st capture group.<br/>
        ///         ○ Match with 4 alternative expressions.<br/>
        ///             ○ 2nd capture group.<br/>
        ///                 ○ Match the string "st".<br/>
        ///             ○ 3rd capture group.<br/>
        ///                 ○ Match the string "nd".<br/>
        ///             ○ 4th capture group.<br/>
        ///                 ○ Match the string "rd".<br/>
        ///             ○ 5th capture group.<br/>
        ///                 ○ Match the string "th".<br/>
        /// ○ Match ' '.<br/>
        /// ○ "month" capture group.<br/>
        ///     ○ Match a character in the set [A-Za-z] atomically at least once.<br/>
        /// ○ Match ' '.<br/>
        /// ○ "year" capture group.<br/>
        ///     ○ Match a Unicode digit exactly 4 times.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex DatesRegex() => global::System.Text.RegularExpressions.Generated.DatesRegex_7.Instance;
    }
}

namespace GeneratedRegexSamplesApp.Classes
{
    partial class RegularExpressionHelpers
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>([A-Z][a-z]+)</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ 1st capture group.<br/>
        ///     ○ Match a character in the set [A-Z].<br/>
        ///     ○ Match a character in the set [a-z] atomically at least once.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex CasingRegex() => global::System.Text.RegularExpressions.Generated.CasingRegex_8.Instance;
    }
}

namespace GeneratedRegexSamplesApp.Classes
{
    partial class SpectreConsoleHelpers
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>([A-Z][a-z]+)</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ 1st capture group.<br/>
        ///     ○ Match a character in the set [A-Z].<br/>
        ///     ○ Match a character in the set [a-z] atomically at least once.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex SplitterRegex() => global::System.Text.RegularExpressions.Generated.CasingRegex_8.Instance;
    }
}

namespace System.Text.RegularExpressions.Generated
{
    using System;
    using System.Buffers;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Threading;

    /// <summary>Custom <see cref="Regex"/>-derived type for the ProductUrlRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class ProductUrlRegex_0 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly ProductUrlRegex_0 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private ProductUrlRegex_0()
        {
            base.pattern = "(?<scheme>.+?://)(?<host>[0-9a-z\\-\\.]+)(?<path>/product/(?<pid>\\d+))";
            base.roptions = RegexOptions.IgnoreCase | RegexOptions.Compiled;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.CapNames = new Hashtable { { "0", 0 } ,  { "host", 2 } ,  { "path", 3 } ,  { "pid", 4 } ,  { "scheme", 1 }  };
            base.capslist = new string[] {"0", "scheme", "host", "path", "pid" };
            base.capsize = 5;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 15 characters.
                    if (pos <= inputSpan.Length - 15)
                    {
                        // The pattern begins with a character in the set [^\n].
                        // Find the next occurrence. If it can't be found, there's no match.
                        ReadOnlySpan<char> span = inputSpan.Slice(pos);
                        for (int i = 0; i < span.Length; i++)
                        {
                            if ((span[i] != '\n'))
                            {
                                base.runtextpos = pos + i;
                                return true;
                            }
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    char ch;
                    int capture_starting_pos = 0;
                    int capture_starting_pos1 = 0;
                    int capture_starting_pos2 = 0;
                    int capture_starting_pos3 = 0;
                    int lazyloop_capturepos = 0;
                    int lazyloop_pos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // "scheme" capture group.
                    //{
                        capture_starting_pos = pos;
                        
                        // Match a character other than '\n' lazily at least once.
                        //{
                            if (slice.IsEmpty || slice[0] == '\n')
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            
                            pos++;
                            slice = inputSpan.Slice(pos);
                            lazyloop_pos = pos;
                            goto LazyLoopEnd;
                            
                            LazyLoopBacktrack:
                            UncaptureUntil(lazyloop_capturepos);
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            pos = lazyloop_pos;
                            slice = inputSpan.Slice(pos);
                            if (slice.IsEmpty || slice[0] == '\n')
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            pos++;
                            slice = inputSpan.Slice(pos);
                            lazyloop_pos = slice.IndexOfAny('\n', ':');
                            if ((uint)lazyloop_pos >= (uint)slice.Length || slice[lazyloop_pos] == '\n')
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            pos += lazyloop_pos;
                            slice = inputSpan.Slice(pos);
                            lazyloop_pos = pos;
                            
                            LazyLoopEnd:
                            lazyloop_capturepos = base.Crawlpos();
                        //}
                        
                        // Match the string "://".
                        if (!slice.StartsWith("://"))
                        {
                            goto LazyLoopBacktrack;
                        }
                        
                        pos += 3;
                        slice = inputSpan.Slice(pos);
                        base.Capture(1, capture_starting_pos, pos);
                        
                        goto CaptureSkipBacktrack;
                        
                        CaptureBacktrack:
                        goto LazyLoopBacktrack;
                        
                        CaptureSkipBacktrack:;
                    //}
                    
                    // "host" capture group.
                    {
                        capture_starting_pos1 = pos;
                        
                        // Match a character in the set [-.0-9A-Za-z\u0130\u212A] atomically at least once.
                        {
                            int iteration = 0;
                            while ((uint)iteration < (uint)slice.Length && ((ch = slice[iteration]) < 128 ? ("\0\0怀Ͽ\ufffe\u07ff\ufffe\u07ff"[ch >> 4] & (1 << (ch & 0xF))) != 0 : RegexRunner.CharInClass((char)ch, "\0\f\0-/0:A[a{İıKÅ")))
                            {
                                iteration++;
                            }
                            
                            if (iteration == 0)
                            {
                                goto CaptureBacktrack;
                            }
                            
                            slice = slice.Slice(iteration);
                            pos += iteration;
                        }
                        
                        base.Capture(2, capture_starting_pos1, pos);
                    }
                    
                    // "path" capture group.
                    {
                        capture_starting_pos2 = pos;
                        
                        if ((uint)slice.Length < 9 ||
                            !slice.StartsWith("/product/", StringComparison.OrdinalIgnoreCase)) // Match the string "/product/" (ordinal case-insensitive)
                        {
                            goto CaptureBacktrack;
                        }
                        
                        // "pid" capture group.
                        {
                            pos += 9;
                            slice = inputSpan.Slice(pos);
                            capture_starting_pos3 = pos;
                            
                            // Match a Unicode digit atomically at least once.
                            {
                                int iteration1 = 0;
                                while ((uint)iteration1 < (uint)slice.Length && char.IsDigit(slice[iteration1]))
                                {
                                    iteration1++;
                                }
                                
                                if (iteration1 == 0)
                                {
                                    goto CaptureBacktrack;
                                }
                                
                                slice = slice.Slice(iteration1);
                                pos += iteration1;
                            }
                            
                            base.Capture(4, capture_starting_pos3, pos);
                        }
                        
                        base.Capture(3, capture_starting_pos2, pos);
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the DateRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class DateRegex_1 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly DateRegex_1 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private DateRegex_1()
        {
            base.pattern = "\\d{1,2}/\\d{1,2}/\\d{4} \\d{1,2}:\\d{2}:\\d{2} [AP]M";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 19 characters.
                    if (pos <= inputSpan.Length - 19)
                    {
                        // The pattern begins with a Unicode digit.
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAnyDigit();
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    char ch;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match a Unicode digit atomically at least 1 and at most 2 times.
                    {
                        int iteration = 0;
                        while (iteration < 2 && (uint)iteration < (uint)slice.Length && char.IsDigit(slice[iteration]))
                        {
                            iteration++;
                        }
                        
                        if (iteration == 0)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration);
                        pos += iteration;
                    }
                    
                    // Match '/'.
                    if (slice.IsEmpty || slice[0] != '/')
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match a Unicode digit atomically at least 1 and at most 2 times.
                    {
                        pos++;
                        slice = inputSpan.Slice(pos);
                        int iteration1 = 0;
                        while (iteration1 < 2 && (uint)iteration1 < (uint)slice.Length && char.IsDigit(slice[iteration1]))
                        {
                            iteration1++;
                        }
                        
                        if (iteration1 == 0)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration1);
                        pos += iteration1;
                    }
                    
                    if ((uint)slice.Length < 6 ||
                        slice[0] != '/' || // Match '/'.
                        !char.IsDigit(slice[1]) || // Match a Unicode digit exactly 4 times.
                        !char.IsDigit(slice[2]) ||
                        !char.IsDigit(slice[3]) ||
                        !char.IsDigit(slice[4]) ||
                        slice[5] != ' ') // Match ' '.
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match a Unicode digit atomically at least 1 and at most 2 times.
                    {
                        pos += 6;
                        slice = inputSpan.Slice(pos);
                        int iteration2 = 0;
                        while (iteration2 < 2 && (uint)iteration2 < (uint)slice.Length && char.IsDigit(slice[iteration2]))
                        {
                            iteration2++;
                        }
                        
                        if (iteration2 == 0)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration2);
                        pos += iteration2;
                    }
                    
                    if ((uint)slice.Length < 9 ||
                        slice[0] != ':' || // Match ':'.
                        !char.IsDigit(slice[1]) || // Match a Unicode digit exactly 2 times.
                        !char.IsDigit(slice[2]) ||
                        slice[3] != ':' || // Match ':'.
                        !char.IsDigit(slice[4]) || // Match a Unicode digit exactly 2 times.
                        !char.IsDigit(slice[5]) ||
                        slice[6] != ' ' || // Match ' '.
                        (((ch = slice[7]) != 'A') & (ch != 'P')) || // Match a character in the set [AP].
                        slice[8] != 'M') // Match 'M'.
                    {
                        return false; // The input didn't match.
                    }
                    
                    // The input matched.
                    pos += 9;
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the CreditCardRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class CreditCardRegex_2 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly CreditCardRegex_2 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private CreditCardRegex_2()
        {
            base.pattern = "[0-9][0-9 ]{13,}[0-9]";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    uint charMinusLowUInt32;
                    
                    // Any possible match is at least 15 characters.
                    if (pos <= inputSpan.Length - 15)
                    {
                        // The pattern begins with a character in the set [0-9].
                        // Find the next occurrence. If it can't be found, there's no match.
                        ReadOnlySpan<char> span = inputSpan.Slice(pos);
                        for (int i = 0; i < span.Length - 14; i++)
                        {
                            int indexOfPos = span.Slice(i).IndexOfAnyInRange('0', '9');
                            if (indexOfPos < 0)
                            {
                                goto NoMatchFound;
                            }
                            i += indexOfPos;
                            
                            // The primary set being searched for was found. 2 more sets will be checked so as
                            // to minimize the number of places TryMatchAtCurrentPosition is run unnecessarily.
                            // Make sure they fit in the remainder of the input.
                            if ((uint)(i + 2) >= (uint)span.Length)
                            {
                                goto NoMatchFound;
                            }
                            
                            if (((int)((0x8000FFC0U << (short)(charMinusLowUInt32 = (ushort)(span[i + 1] - ' '))) & (charMinusLowUInt32 - 32)) < 0) &&
                                ((int)((0x8000FFC0U << (short)(charMinusLowUInt32 = (ushort)(span[i + 2] - ' '))) & (charMinusLowUInt32 - 32)) < 0))
                            {
                                base.runtextpos = pos + i;
                                return true;
                            }
                        }
                    }
                    
                    // No match found.
                    NoMatchFound:
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match a character in the set [0-9].
                    if (slice.IsEmpty || !char.IsAsciiDigit(slice[0]))
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match a character in the set [ 0-9] greedily at least 13 times.
                    //{
                        pos++;
                        slice = inputSpan.Slice(pos);
                        charloop_starting_pos = pos;
                        
                        int iteration = slice.IndexOfAnyExcept(Utilities.s_ascii_100FF030000000000000000);
                        if (iteration < 0)
                        {
                            iteration = slice.Length;
                        }
                        
                        if (iteration < 13)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration);
                        pos += iteration;
                        
                        charloop_ending_pos = pos;
                        charloop_starting_pos += 13;
                        goto CharLoopEnd;
                        
                        CharLoopBacktrack:
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        if (charloop_starting_pos >= charloop_ending_pos ||
                            (charloop_ending_pos = inputSpan.Slice(charloop_starting_pos, charloop_ending_pos - charloop_starting_pos).LastIndexOfAnyInRange('0', '9')) < 0)
                        {
                            return false; // The input didn't match.
                        }
                        charloop_ending_pos += charloop_starting_pos;
                        pos = charloop_ending_pos;
                        slice = inputSpan.Slice(pos);
                        
                        CharLoopEnd:
                    //}
                    
                    // Match a character in the set [0-9].
                    if (slice.IsEmpty || !char.IsAsciiDigit(slice[0]))
                    {
                        goto CharLoopBacktrack;
                    }
                    
                    // The input matched.
                    pos++;
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the MultipleSpacesRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class MultipleSpacesRegex_3 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly MultipleSpacesRegex_3 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private MultipleSpacesRegex_3()
        {
            base.pattern = "[ ]{2,}";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 2 characters.
                    if (pos <= inputSpan.Length - 2)
                    {
                        // The pattern has the literal "  " at the beginning of the pattern. Find the next occurrence.
                        // If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOf("  ");
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match ' ' atomically at least twice.
                    {
                        int iteration = slice.IndexOfAnyExcept(' ');
                        if (iteration < 0)
                        {
                            iteration = slice.Length;
                        }
                        
                        if (iteration < 2)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration);
                        pos += iteration;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the SentenceCaseRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class SentenceCaseRegex_4 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly SentenceCaseRegex_4 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private SentenceCaseRegex_4()
        {
            base.pattern = "(^[a-z])|\\.\\s+(.)";
            base.roptions = RegexOptions.ExplicitCapture;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a character in the set [.a-z].
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_ascii_40000000000000FEFFFF07);
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    int stackpos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Atomic group.
                    {
                        int atomic_stackpos = stackpos;
                        
                        // Match with 2 alternative expressions, atomically.
                        //{
                            int alternation_starting_pos = pos;
                            
                            // Branch 0
                            {
                                // Match if at the beginning of the string.
                                if (pos != 0)
                                {
                                    goto AlternationBranch;
                                }
                                
                                // Match a character in the set [a-z].
                                if (slice.IsEmpty || !char.IsAsciiLetterLower(slice[0]))
                                {
                                    goto AlternationBranch;
                                }
                                
                                pos++;
                                slice = inputSpan.Slice(pos);
                                goto AlternationMatch;
                                
                                AlternationBranch:
                                pos = alternation_starting_pos;
                                slice = inputSpan.Slice(pos);
                            }
                            
                            // Branch 1
                            {
                                // Match '.'.
                                if (slice.IsEmpty || slice[0] != '.')
                                {
                                    return false; // The input didn't match.
                                }
                                
                                // Match a whitespace character greedily at least once.
                                //{
                                    pos++;
                                    slice = inputSpan.Slice(pos);
                                    charloop_starting_pos = pos;
                                    
                                    int iteration = 0;
                                    while ((uint)iteration < (uint)slice.Length && char.IsWhiteSpace(slice[iteration]))
                                    {
                                        iteration++;
                                    }
                                    
                                    if (iteration == 0)
                                    {
                                        return false; // The input didn't match.
                                    }
                                    
                                    slice = slice.Slice(iteration);
                                    pos += iteration;
                                    
                                    charloop_ending_pos = pos;
                                    charloop_starting_pos++;
                                    goto CharLoopEnd;
                                    
                                    CharLoopBacktrack:
                                    
                                    if (Utilities.s_hasTimeout)
                                    {
                                        base.CheckTimeout();
                                    }
                                    
                                    if (charloop_starting_pos >= charloop_ending_pos ||
                                        (charloop_ending_pos = inputSpan.Slice(charloop_starting_pos, charloop_ending_pos - charloop_starting_pos).LastIndexOfAnyExcept('\n')) < 0)
                                    {
                                        return false; // The input didn't match.
                                    }
                                    charloop_ending_pos += charloop_starting_pos;
                                    pos = charloop_ending_pos;
                                    slice = inputSpan.Slice(pos);
                                    
                                    CharLoopEnd:
                                //}
                                
                                // Match any character other than '\n'.
                                if (slice.IsEmpty || slice[0] == '\n')
                                {
                                    goto CharLoopBacktrack;
                                }
                                
                                pos++;
                                slice = inputSpan.Slice(pos);
                            }
                            
                            AlternationMatch:;
                        //}
                        
                        stackpos = atomic_stackpos;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the SSNValidationRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class SSNValidationRegex_5 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly SSNValidationRegex_5 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private SSNValidationRegex_5()
        {
            base.pattern = "^(?!\\b(\\d)\\1+\\b)(?!123456789|219099999|078051120)(?!666|000|9\\d{2})\\d{3}(?!00)\\d{2}(?!0{4})\\d{4}$";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 2;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // The pattern is anchored.  Validate the current position and try to match at it only.
                    if (TryFindNextPossibleStartingPosition(inputSpan) && !TryMatchAtCurrentPosition(inputSpan))
                    {
                        base.runtextpos = inputSpan.Length;
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 9 characters.
                    if (pos <= inputSpan.Length - 9)
                    {
                        // The pattern leads with a beginning (\A) anchor.
                        if (pos == 0)
                        {
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int capture_starting_pos = 0;
                    int loop_iteration = 0, loop_starting_pos = 0;
                    int matchLength = 0;
                    int stackpos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match if at the beginning of the string.
                    if (pos != 0)
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // Zero-width negative lookahead.
                    {
                        int negativelookahead_starting_pos = pos;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        int atomic_stackpos = stackpos;
                        
                        // Match if at a word boundary.
                        if (!Utilities.IsBoundary(inputSpan, pos))
                        {
                            goto NegativeLookaroundMatch;
                        }
                        
                        // 1st capture group.
                        {
                            capture_starting_pos = pos;
                            
                            // Match a Unicode digit.
                            if (slice.IsEmpty || !char.IsDigit(slice[0]))
                            {
                                goto NegativeLookaroundMatch;
                            }
                            
                            pos++;
                            slice = inputSpan.Slice(pos);
                            base.Capture(1, capture_starting_pos, pos);
                        }
                        
                        // Loop greedily at least once.
                        //{
                            loop_starting_pos = pos;
                            loop_iteration = 0;
                            
                            LoopBody:
                            Utilities.StackPush(ref base.runstack!, ref stackpos, base.Crawlpos(), loop_starting_pos, pos);
                            
                            loop_starting_pos = pos;
                            loop_iteration++;
                            
                            // Match the same text as matched by the 1st capture group.
                            {
                                // If the 1st capture group hasn't matched, the backreference doesn't match.
                                if (!base.IsMatched(1))
                                {
                                    goto LoopIterationNoMatch;
                                }
                                
                                // Get the captured text.  If it doesn't match at the current position, the backreference doesn't match.
                                matchLength = base.MatchLength(1);
                                if (slice.Length < matchLength || 
                                    !inputSpan.Slice(base.MatchIndex(1), matchLength).SequenceEqual(slice.Slice(0, matchLength)))
                                {
                                    goto LoopIterationNoMatch;
                                }
                                
                                pos += matchLength;
                                slice = inputSpan.Slice(pos);
                            }
                            
                            
                            // The loop has a lower bound of 1 but no upper bound. Continue iterating greedily
                            // if the last iteration wasn't empty (or if it was, if the lower bound hasn't yet been reached).
                            if (pos != loop_starting_pos || loop_iteration == 0)
                            {
                                goto LoopBody;
                            }
                            goto LoopEnd;
                            
                            // The loop iteration failed. Put state back to the way it was before the iteration.
                            LoopIterationNoMatch:
                            if (--loop_iteration < 0)
                            {
                                // Unable to match the remainder of the expression after exhausting the loop.
                                goto NegativeLookaroundMatch;
                            }
                            Utilities.StackPop(base.runstack!, ref stackpos, out pos, out loop_starting_pos);
                            UncaptureUntil(base.runstack![--stackpos]);
                            slice = inputSpan.Slice(pos);
                            if (loop_iteration == 0)
                            {
                                // All possible iterations have matched, but it's below the required minimum of 1. Fail the loop.
                                goto NegativeLookaroundMatch;
                            }
                            
                            LoopEnd:;
                        //}
                        
                        // Match if at a word boundary.
                        if (!Utilities.IsBoundary(inputSpan, pos))
                        {
                            goto LoopIterationNoMatch;
                        }
                        
                        stackpos = atomic_stackpos;
                        
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                        
                        NegativeLookaroundMatch:
                        pos = negativelookahead_starting_pos;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Zero-width negative lookahead.
                    {
                        int negativelookahead_starting_pos1 = pos;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        // Match with 3 alternative expressions, atomically.
                        {
                            if (slice.IsEmpty)
                            {
                                goto NegativeLookaroundMatch1;
                            }
                            
                            switch (slice[0])
                            {
                                case '1':
                                    // Match the string "23456789".
                                    if (!slice.Slice(1).StartsWith("23456789"))
                                    {
                                        goto NegativeLookaroundMatch1;
                                    }
                                    
                                    pos += 9;
                                    slice = inputSpan.Slice(pos);
                                    break;
                                    
                                case '2':
                                    // Match the string "19099999".
                                    if (!slice.Slice(1).StartsWith("19099999"))
                                    {
                                        goto NegativeLookaroundMatch1;
                                    }
                                    
                                    pos += 9;
                                    slice = inputSpan.Slice(pos);
                                    break;
                                    
                                case '0':
                                    // Match the string "78051120".
                                    if (!slice.Slice(1).StartsWith("78051120"))
                                    {
                                        goto NegativeLookaroundMatch1;
                                    }
                                    
                                    pos += 9;
                                    slice = inputSpan.Slice(pos);
                                    break;
                                    
                                default:
                                    goto NegativeLookaroundMatch1;
                            }
                        }
                        
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                        
                        NegativeLookaroundMatch1:
                        pos = negativelookahead_starting_pos1;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Zero-width negative lookahead.
                    {
                        int negativelookahead_starting_pos2 = pos;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        // Match with 3 alternative expressions, atomically.
                        {
                            if (slice.IsEmpty)
                            {
                                goto NegativeLookaroundMatch2;
                            }
                            
                            switch (slice[0])
                            {
                                case '6':
                                    // Match the string "66".
                                    if (!slice.Slice(1).StartsWith("66"))
                                    {
                                        goto NegativeLookaroundMatch2;
                                    }
                                    
                                    pos += 3;
                                    slice = inputSpan.Slice(pos);
                                    break;
                                    
                                case '0':
                                    // Match the string "00".
                                    if (!slice.Slice(1).StartsWith("00"))
                                    {
                                        goto NegativeLookaroundMatch2;
                                    }
                                    
                                    pos += 3;
                                    slice = inputSpan.Slice(pos);
                                    break;
                                    
                                case '9':
                                    // Match a Unicode digit exactly 2 times.
                                    {
                                        if ((uint)slice.Length < 3 ||
                                            !char.IsDigit(slice[1]) ||
                                            !char.IsDigit(slice[2]))
                                        {
                                            goto NegativeLookaroundMatch2;
                                        }
                                    }
                                    
                                    pos += 3;
                                    slice = inputSpan.Slice(pos);
                                    break;
                                    
                                default:
                                    goto NegativeLookaroundMatch2;
                            }
                        }
                        
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                        
                        NegativeLookaroundMatch2:
                        pos = negativelookahead_starting_pos2;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Match a Unicode digit exactly 3 times.
                    {
                        if ((uint)slice.Length < 3 ||
                            !char.IsDigit(slice[0]) ||
                            !char.IsDigit(slice[1]) ||
                            !char.IsDigit(slice[2]))
                        {
                            UncaptureUntil(0);
                            return false; // The input didn't match.
                        }
                    }
                    
                    // Zero-width negative lookahead.
                    {
                        int negativelookahead_starting_pos3 = pos;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        // Match the string "00".
                        if (!slice.Slice(3).StartsWith("00"))
                        {
                            goto NegativeLookaroundMatch3;
                        }
                        
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                        
                        NegativeLookaroundMatch3:
                        pos = negativelookahead_starting_pos3;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Match a Unicode digit exactly 2 times.
                    {
                        if ((uint)slice.Length < 5 ||
                            !char.IsDigit(slice[3]) ||
                            !char.IsDigit(slice[4]))
                        {
                            UncaptureUntil(0);
                            return false; // The input didn't match.
                        }
                    }
                    
                    // Zero-width negative lookahead.
                    {
                        int negativelookahead_starting_pos4 = pos;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        // Match the string "0000".
                        if (!slice.Slice(5).StartsWith("0000"))
                        {
                            goto NegativeLookaroundMatch4;
                        }
                        
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                        
                        NegativeLookaroundMatch4:
                        pos = negativelookahead_starting_pos4;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Match a Unicode digit exactly 4 times.
                    {
                        if ((uint)slice.Length < 9 ||
                            !char.IsDigit(slice[5]) ||
                            !char.IsDigit(slice[6]) ||
                            !char.IsDigit(slice[7]) ||
                            !char.IsDigit(slice[8]))
                        {
                            UncaptureUntil(0);
                            return false; // The input didn't match.
                        }
                    }
                    
                    // Match if at the end of the string or if before an ending newline.
                    if (10 < slice.Length || (9 < slice.Length && slice[9] != '\n'))
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // The input matched.
                    pos += 9;
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the NumbersPatternRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class NumbersPatternRegex_6 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly NumbersPatternRegex_6 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private NumbersPatternRegex_6()
        {
            base.pattern = "[0-9]+$";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a character in the set [0-9].
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAnyInRange('0', '9');
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match a character in the set [0-9] atomically at least once.
                    {
                        int iteration = slice.IndexOfAnyExceptInRange('0', '9');
                        if (iteration < 0)
                        {
                            iteration = slice.Length;
                        }
                        
                        if (iteration == 0)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration);
                        pos += iteration;
                    }
                    
                    // Advance the next matching position.
                    if (base.runtextpos < pos)
                    {
                        base.runtextpos = pos;
                    }
                    
                    // Match if at the end of the string or if before an ending newline.
                    if (pos < inputSpan.Length - 1 || ((uint)pos < (uint)inputSpan.Length && inputSpan[pos] != '\n'))
                    {
                        return false; // The input didn't match.
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the DatesRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class DatesRegex_7 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly DatesRegex_7 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private DatesRegex_7()
        {
            base.pattern = "(?<day>\\d{1,2})((st)|(nd)|(rd)|(th))? (?<month>[A-Za-z]+) (?<year>\\d{4})";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.CapNames = new Hashtable { { "0", 0 } ,  { "1", 1 } ,  { "2", 2 } ,  { "3", 3 } ,  { "4", 4 } ,  { "5", 5 } ,  { "day", 6 } ,  { "month", 7 } ,  { "year", 8 }  };
            base.capslist = new string[] {"0", "1", "2", "3", "4", "5", "day", "month", "year" };
            base.capsize = 9;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 8 characters.
                    if (pos <= inputSpan.Length - 8)
                    {
                        // The pattern begins with a Unicode digit.
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAnyDigit();
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int capture_starting_pos = 0;
                    int capture_starting_pos6 = 0;
                    int capture_starting_pos7 = 0;
                    int charloop_capture_pos = 0;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    int loop_iteration = 0;
                    int stackpos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // "day" capture group.
                    //{
                        capture_starting_pos = pos;
                        
                        // Match a Unicode digit greedily at least 1 and at most 2 times.
                        //{
                            charloop_starting_pos = pos;
                            
                            int iteration = 0;
                            while (iteration < 2 && (uint)iteration < (uint)slice.Length && char.IsDigit(slice[iteration]))
                            {
                                iteration++;
                            }
                            
                            if (iteration == 0)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            
                            slice = slice.Slice(iteration);
                            pos += iteration;
                            
                            charloop_ending_pos = pos;
                            charloop_starting_pos++;
                            goto CharLoopEnd;
                            
                            CharLoopBacktrack:
                            UncaptureUntil(charloop_capture_pos);
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos >= charloop_ending_pos)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            pos = --charloop_ending_pos;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd:
                            charloop_capture_pos = base.Crawlpos();
                        //}
                        
                        base.Capture(6, capture_starting_pos, pos);
                        
                        goto CaptureSkipBacktrack;
                        
                        CaptureBacktrack:
                        goto CharLoopBacktrack;
                        
                        CaptureSkipBacktrack:;
                    //}
                    
                    // Optional (greedy).
                    //{
                        loop_iteration = 0;
                        
                        LoopBody:
                        Utilities.StackPush(ref base.runstack!, ref stackpos, base.Crawlpos(), pos);
                        
                        loop_iteration++;
                        
                        // 1st capture group.
                        //{
                            int capture_starting_pos1 = pos;
                            
                            // Match with 4 alternative expressions.
                            //{
                                int alternation_starting_pos = pos;
                                int alternation_starting_capturepos = base.Crawlpos();
                                
                                // Branch 0
                                //{
                                    // 2nd capture group.
                                    {
                                        int capture_starting_pos2 = pos;
                                        
                                        // Match the string "st".
                                        if (!slice.StartsWith("st"))
                                        {
                                            goto AlternationBranch;
                                        }
                                        
                                        pos += 2;
                                        slice = inputSpan.Slice(pos);
                                        base.Capture(2, capture_starting_pos2, pos);
                                    }
                                    
                                    Utilities.StackPush(ref base.runstack!, ref stackpos, 0, alternation_starting_pos, alternation_starting_capturepos);
                                    goto AlternationMatch;
                                    
                                    AlternationBranch:
                                    pos = alternation_starting_pos;
                                    slice = inputSpan.Slice(pos);
                                    UncaptureUntil(alternation_starting_capturepos);
                                //}
                                
                                // Branch 1
                                //{
                                    // 3rd capture group.
                                    {
                                        int capture_starting_pos3 = pos;
                                        
                                        // Match the string "nd".
                                        if (!slice.StartsWith("nd"))
                                        {
                                            goto AlternationBranch1;
                                        }
                                        
                                        pos += 2;
                                        slice = inputSpan.Slice(pos);
                                        base.Capture(3, capture_starting_pos3, pos);
                                    }
                                    
                                    Utilities.StackPush(ref base.runstack!, ref stackpos, 1, alternation_starting_pos, alternation_starting_capturepos);
                                    goto AlternationMatch;
                                    
                                    AlternationBranch1:
                                    pos = alternation_starting_pos;
                                    slice = inputSpan.Slice(pos);
                                    UncaptureUntil(alternation_starting_capturepos);
                                //}
                                
                                // Branch 2
                                //{
                                    // 4th capture group.
                                    {
                                        int capture_starting_pos4 = pos;
                                        
                                        // Match the string "rd".
                                        if (!slice.StartsWith("rd"))
                                        {
                                            goto AlternationBranch2;
                                        }
                                        
                                        pos += 2;
                                        slice = inputSpan.Slice(pos);
                                        base.Capture(4, capture_starting_pos4, pos);
                                    }
                                    
                                    Utilities.StackPush(ref base.runstack!, ref stackpos, 2, alternation_starting_pos, alternation_starting_capturepos);
                                    goto AlternationMatch;
                                    
                                    AlternationBranch2:
                                    pos = alternation_starting_pos;
                                    slice = inputSpan.Slice(pos);
                                    UncaptureUntil(alternation_starting_capturepos);
                                //}
                                
                                // Branch 3
                                //{
                                    // 5th capture group.
                                    {
                                        int capture_starting_pos5 = pos;
                                        
                                        // Match the string "th".
                                        if (!slice.StartsWith("th"))
                                        {
                                            goto LoopIterationNoMatch;
                                        }
                                        
                                        pos += 2;
                                        slice = inputSpan.Slice(pos);
                                        base.Capture(5, capture_starting_pos5, pos);
                                    }
                                    
                                    Utilities.StackPush(ref base.runstack!, ref stackpos, 3, alternation_starting_pos, alternation_starting_capturepos);
                                    goto AlternationMatch;
                                //}
                                
                                AlternationBacktrack:
                                if (Utilities.s_hasTimeout)
                                {
                                    base.CheckTimeout();
                                }
                                
                                Utilities.StackPop(base.runstack!, ref stackpos, out alternation_starting_capturepos, out alternation_starting_pos);
                                switch (base.runstack![--stackpos])
                                {
                                    case 0:
                                        goto AlternationBranch;
                                    case 1:
                                        goto AlternationBranch1;
                                    case 2:
                                        goto AlternationBranch2;
                                    case 3:
                                        goto LoopIterationNoMatch;
                                }
                                
                                AlternationMatch:;
                            //}
                            
                            base.Capture(1, capture_starting_pos1, pos);
                            
                            Utilities.StackPush(ref base.runstack!, ref stackpos, capture_starting_pos1);
                            goto CaptureSkipBacktrack1;
                            
                            CaptureBacktrack1:
                            capture_starting_pos1 = base.runstack![--stackpos];
                            goto AlternationBacktrack;
                            
                            CaptureSkipBacktrack1:;
                        //}
                        
                        
                        // The loop has an upper bound of 1. Continue iterating greedily if it hasn't yet been reached.
                        if (loop_iteration == 0)
                        {
                            goto LoopBody;
                        }
                        goto LoopEnd;
                        
                        // The loop iteration failed. Put state back to the way it was before the iteration.
                        LoopIterationNoMatch:
                        if (--loop_iteration < 0)
                        {
                            // Unable to match the remainder of the expression after exhausting the loop.
                            goto CaptureBacktrack;
                        }
                        pos = base.runstack![--stackpos];
                        UncaptureUntil(base.runstack![--stackpos]);
                        slice = inputSpan.Slice(pos);
                        goto LoopEnd;
                        
                        LoopBacktrack:
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        if (loop_iteration == 0)
                        {
                            // No iterations of the loop remain to backtrack into. Fail the loop.
                            goto CaptureBacktrack;
                        }
                        goto CaptureBacktrack1;
                        LoopEnd:;
                    //}
                    
                    // Match ' '.
                    if (slice.IsEmpty || slice[0] != ' ')
                    {
                        goto LoopBacktrack;
                    }
                    
                    // "month" capture group.
                    {
                        pos++;
                        slice = inputSpan.Slice(pos);
                        capture_starting_pos6 = pos;
                        
                        // Match a character in the set [A-Za-z] atomically at least once.
                        {
                            int iteration1 = slice.IndexOfAnyExcept(Utilities.s_asciiLetters);
                            if (iteration1 < 0)
                            {
                                iteration1 = slice.Length;
                            }
                            
                            if (iteration1 == 0)
                            {
                                goto LoopBacktrack;
                            }
                            
                            slice = slice.Slice(iteration1);
                            pos += iteration1;
                        }
                        
                        base.Capture(7, capture_starting_pos6, pos);
                    }
                    
                    // Match ' '.
                    if (slice.IsEmpty || slice[0] != ' ')
                    {
                        goto LoopBacktrack;
                    }
                    
                    // "year" capture group.
                    {
                        pos++;
                        slice = inputSpan.Slice(pos);
                        capture_starting_pos7 = pos;
                        
                        // Match a Unicode digit exactly 4 times.
                        {
                            if ((uint)slice.Length < 4 ||
                                !char.IsDigit(slice[0]) ||
                                !char.IsDigit(slice[1]) ||
                                !char.IsDigit(slice[2]) ||
                                !char.IsDigit(slice[3]))
                            {
                                goto LoopBacktrack;
                            }
                        }
                        
                        pos += 4;
                        slice = inputSpan.Slice(pos);
                        base.Capture(8, capture_starting_pos7, pos);
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the CasingRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file sealed class CasingRegex_8 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly CasingRegex_8 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private CasingRegex_8()
        {
            base.pattern = "([A-Z][a-z]+)";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 2;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 2 characters.
                    if (pos <= inputSpan.Length - 2)
                    {
                        // The pattern begins with a character in the set [A-Z].
                        // Find the next occurrence. If it can't be found, there's no match.
                        ReadOnlySpan<char> span = inputSpan.Slice(pos);
                        for (int i = 0; i < span.Length - 1; i++)
                        {
                            int indexOfPos = span.Slice(i).IndexOfAnyInRange('A', 'Z');
                            if (indexOfPos < 0)
                            {
                                goto NoMatchFound;
                            }
                            i += indexOfPos;
                            
                            // The primary set being searched for was found. 1 more set will be checked so as
                            // to minimize the number of places TryMatchAtCurrentPosition is run unnecessarily.
                            // Make sure it fits in the remainder of the input.
                            if ((uint)(i + 1) >= (uint)span.Length)
                            {
                                goto NoMatchFound;
                            }
                            
                            if (char.IsAsciiLetterLower(span[i + 1]))
                            {
                                base.runtextpos = pos + i;
                                return true;
                            }
                        }
                    }
                    
                    // No match found.
                    NoMatchFound:
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int capture_starting_pos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // 1st capture group.
                    {
                        capture_starting_pos = pos;
                        
                        // Match a character in the set [A-Z].
                        if (slice.IsEmpty || !char.IsAsciiLetterUpper(slice[0]))
                        {
                            UncaptureUntil(0);
                            return false; // The input didn't match.
                        }
                        
                        // Match a character in the set [a-z] atomically at least once.
                        {
                            int iteration = slice.Slice(1).IndexOfAnyExceptInRange('a', 'z');
                            if (iteration < 0)
                            {
                                iteration = slice.Length - 1;
                            }
                            
                            if (iteration == 0)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            
                            slice = slice.Slice(iteration);
                            pos += iteration;
                        }
                        
                        pos++;
                        slice = inputSpan.Slice(pos);
                        base.Capture(1, capture_starting_pos, pos);
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Helper methods used by generated <see cref="Regex"/>-derived implementations.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file static class Utilities
    {
        /// <summary>Default timeout value set in <see cref="AppContext"/>, or <see cref="Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        internal static readonly TimeSpan s_defaultTimeout = AppContext.GetData("REGEX_DEFAULT_MATCH_TIMEOUT") is TimeSpan timeout ? timeout : Regex.InfiniteMatchTimeout;
        
        /// <summary>Whether <see cref="s_defaultTimeout"/> is non-infinite.</summary>
        internal static readonly bool s_hasTimeout = s_defaultTimeout != Regex.InfiniteMatchTimeout;
        
        /// <summary>Finds the next index of any character that matches a Unicode digit.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int IndexOfAnyDigit(this ReadOnlySpan<char> span)
        {
            int i = span.IndexOfAnyExcept(Utilities.s_asciiExceptDigits);
            if ((uint)i < (uint)span.Length)
            {
                if (char.IsAscii(span[i]))
                {
                    return i;
                }
        
                do
                {
                    if (char.IsDigit(span[i]))
                    {
                        return i;
                    }
                    i++;
                }
                while ((uint)i < (uint)span.Length);
            }
        
            return -1;
        }
        
        /// <summary>Determines whether the specified index is a boundary.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool IsBoundary(ReadOnlySpan<char> inputSpan, int index)
        {
            int indexMinus1 = index - 1;
            return ((uint)indexMinus1 < (uint)inputSpan.Length && IsBoundaryWordChar(inputSpan[indexMinus1])) !=
                   ((uint)index < (uint)inputSpan.Length && IsBoundaryWordChar(inputSpan[index]));
        
            static bool IsBoundaryWordChar(char ch) => IsWordChar(ch) || (ch == '\u200C' | ch == '\u200D');
        }
        
        /// <summary>Determines whether the character is part of the [\w] set.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool IsWordChar(char ch)
        {
            // Mask of Unicode categories that combine to form [\w]
            const int WordCategoriesMask =
                1 << (int)UnicodeCategory.UppercaseLetter |
                1 << (int)UnicodeCategory.LowercaseLetter |
                1 << (int)UnicodeCategory.TitlecaseLetter |
                1 << (int)UnicodeCategory.ModifierLetter |
                1 << (int)UnicodeCategory.OtherLetter |
                1 << (int)UnicodeCategory.NonSpacingMark |
                1 << (int)UnicodeCategory.DecimalDigitNumber |
                1 << (int)UnicodeCategory.ConnectorPunctuation;
        
            // Bitmap for whether each character 0 through 127 is in [\w]
            ReadOnlySpan<byte> ascii = new byte[]
            {
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
                0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07
            };
        
            // If the char is ASCII, look it up in the bitmap. Otherwise, query its Unicode category.
            int chDiv8 = ch >> 3;
            return (uint)chDiv8 < (uint)ascii.Length ?
                (ascii[chDiv8] & (1 << (ch & 0x7))) != 0 :
                (WordCategoriesMask & (1 << (int)CharUnicodeInfo.GetUnicodeCategory(ch))) != 0;
        }
        
        /// <summary>Pops 2 values from the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPop(int[] stack, ref int pos, out int arg0, out int arg1)
        {
            arg0 = stack[--pos];
            arg1 = stack[--pos];
        }
        
        /// <summary>Pushes 1 value onto the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPush(ref int[] stack, ref int pos, int arg0)
        {
            // If there's space available for the value, store it.
            int[] s = stack;
            int p = pos;
            if ((uint)p < (uint)s.Length)
            {
                s[p] = arg0;
                pos++;
                return;
            }
        
            // Otherwise, resize the stack to make room and try again.
            WithResize(ref stack, ref pos, arg0);
        
            // <summary>Resize the backtracking stack array and push 1 value onto the stack.</summary>
            [MethodImpl(MethodImplOptions.NoInlining)]
            static void WithResize(ref int[] stack, ref int pos, int arg0)
            {
                Array.Resize(ref stack, (pos + 0) * 2);
                StackPush(ref stack, ref pos, arg0);
            }
        }
        
        /// <summary>Pushes 2 values onto the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPush(ref int[] stack, ref int pos, int arg0, int arg1)
        {
            // If there's space available for all 2 values, store them.
            int[] s = stack;
            int p = pos;
            if ((uint)(p + 1) < (uint)s.Length)
            {
                s[p] = arg0;
                s[p + 1] = arg1;
                pos += 2;
                return;
            }
        
            // Otherwise, resize the stack to make room and try again.
            WithResize(ref stack, ref pos, arg0, arg1);
        
            // <summary>Resize the backtracking stack array and push 2 values onto the stack.</summary>
            [MethodImpl(MethodImplOptions.NoInlining)]
            static void WithResize(ref int[] stack, ref int pos, int arg0, int arg1)
            {
                Array.Resize(ref stack, (pos + 1) * 2);
                StackPush(ref stack, ref pos, arg0, arg1);
            }
        }
        
        /// <summary>Pushes 3 values onto the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPush(ref int[] stack, ref int pos, int arg0, int arg1, int arg2)
        {
            // If there's space available for all 3 values, store them.
            int[] s = stack;
            int p = pos;
            if ((uint)(p + 2) < (uint)s.Length)
            {
                s[p] = arg0;
                s[p + 1] = arg1;
                s[p + 2] = arg2;
                pos += 3;
                return;
            }
        
            // Otherwise, resize the stack to make room and try again.
            WithResize(ref stack, ref pos, arg0, arg1, arg2);
        
            // <summary>Resize the backtracking stack array and push 3 values onto the stack.</summary>
            [MethodImpl(MethodImplOptions.NoInlining)]
            static void WithResize(ref int[] stack, ref int pos, int arg0, int arg1, int arg2)
            {
                Array.Resize(ref stack, (pos + 2) * 2);
                StackPush(ref stack, ref pos, arg0, arg1, arg2);
            }
        }
        
        /// <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        internal static readonly SearchValues<char> s_asciiExceptDigits = SearchValues.Create("\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f");
        
        /// <summary>Supports searching for characters in or not in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".</summary>
        internal static readonly SearchValues<char> s_asciiLetters = SearchValues.Create("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
        
        /// <summary>Supports searching for characters in or not in " 0123456789".</summary>
        internal static readonly SearchValues<char> s_ascii_100FF030000000000000000 = SearchValues.Create(" 0123456789");
        
        /// <summary>Supports searching for characters in or not in ".abcdefghijklmnopqrstuvwxyz".</summary>
        internal static readonly SearchValues<char> s_ascii_40000000000000FEFFFF07 = SearchValues.Create(".abcdefghijklmnopqrstuvwxyz");
    }
}
